<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Medical Transcription Test Client</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1e3a8a 0%, #3b82f6 50%, #06b6d4 100%);
            min-height: 100vh;
            padding: 20px;
            color: #1f2937;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 25px 50px rgba(0,0,0,0.15);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #dc2626 0%, #ef4444 50%, #f97316 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-weight: 800;
        }

        .header p {
            opacity: 0.95;
            font-size: 1.1rem;
        }

        .content {
            padding: 30px;
        }

        .test-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            margin-bottom: 25px;
        }

        .section {
            background: #f8fafc;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            padding: 20px;
            transition: all 0.3s ease;
        }

        .section:hover {
            border-color: #3b82f6;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.15);
        }

        .section.full-width {
            grid-column: 1 / -1;
        }

        .section.half-width {
            grid-column: span 2;
        }

        .section h3 {
            color: #1f2937;
            margin-bottom: 15px;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #ef4444;
            transition: all 0.3s ease;
        }

        .status-dot.connected {
            background: #10b981;
            box-shadow: 0 0 8px rgba(16, 185, 129, 0.6);
        }

        .status-dot.warning {
            background: #f59e0b;
            box-shadow: 0 0 8px rgba(245, 158, 11, 0.6);
        }

        .input-group {
            margin-bottom: 12px;
        }

        .input-group label {
            display: block;
            margin-bottom: 4px;
            font-weight: 600;
            color: #374151;
            font-size: 13px;
        }

        .input-group input, .input-group select {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 13px;
            transition: all 0.2s ease;
        }

        .input-group input:focus, .input-group select:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.1);
        }

        .btn {
            background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-right: 6px;
            margin-bottom: 6px;
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(59, 130, 246, 0.3);
        }

        .btn:disabled {
            background: #9ca3af;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn.danger {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
        }

        .btn.success {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
        }

        .btn.warning {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
        }

        .btn.small {
            padding: 4px 8px;
            font-size: 11px;
        }

        .response-box {
            background: #f1f5f9;
            border: 1px solid #cbd5e1;
            border-radius: 6px;
            padding: 10px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 11px;
            max-height: 120px;
            overflow-y: auto;
            margin-top: 8px;
        }

        .response-box.success {
            background: #f0fdf4;
            border-color: #bbf7d0;
            color: #166534;
        }

        .response-box.error {
            background: #fef2f2;
            border-color: #fecaca;
            color: #dc2626;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
            gap: 8px;
            margin-top: 10px;
        }

        .stat-card {
            background: white;
            padding: 8px;
            border-radius: 6px;
            text-align: center;
            border: 1px solid #e5e7eb;
        }

        .stat-value {
            font-size: 1.2rem;
            font-weight: 700;
            color: #3b82f6;
            margin-bottom: 2px;
        }

        .stat-label {
            font-size: 0.7rem;
            color: #6b7280;
            font-weight: 500;
        }

        .transcript-container {
            background: white;
            border: 2px solid #e5e7eb;
            border-radius: 10px;
            padding: 20px;
            min-height: 150px;
            font-size: 14px;
            line-height: 1.6;
            color: #1f2937;
            position: relative;
        }

        .transcript-container.empty {
            color: #9ca3af;
            font-style: italic;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
        }

        .transcript-sequence {
            display: inline-block;
            background: #dbeafe;
            color: #1e40af;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 600;
            margin-right: 4px;
            margin-bottom: 2px;
        }

        .log-container {
            background: #111827;
            color: #f3f4f6;
            padding: 15px;
            border-radius: 8px;
            height: 200px;
            overflow-y: auto;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 11px;
            line-height: 1.4;
        }

        .log-entry {
            margin-bottom: 4px;
            padding: 2px 6px;
            border-radius: 3px;
        }

        .log-entry.info {
            background: rgba(59, 130, 246, 0.15);
            border-left: 2px solid #3b82f6;
        }

        .log-entry.success {
            background: rgba(16, 185, 129, 0.15);
            border-left: 2px solid #10b981;
        }

        .log-entry.error {
            background: rgba(239, 68, 68, 0.15);
            border-left: 2px solid #ef4444;
        }

        .log-entry.websocket {
            background: rgba(168, 85, 247, 0.15);
            border-left: 2px solid #a855f7;
        }

        .log-entry.warning {
            background: rgba(245, 158, 11, 0.15);
            border-left: 2px solid #f59e0b;
        }

        .test-mode-selector {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 8px;
            margin-bottom: 15px;
        }

        .test-mode {
            padding: 8px;
            background: #f3f4f6;
            border: 2px solid #e5e7eb;
            border-radius: 6px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 12px;
        }

        .test-mode.active {
            border-color: #3b82f6;
            background: #dbeafe;
            color: #1e40af;
            font-weight: 600;
        }

        .race-condition-indicator {
            background: #fef3c7;
            border: 1px solid #f59e0b;
            border-radius: 6px;
            padding: 10px;
            margin-top: 10px;
            font-size: 12px;
        }

        .race-condition-indicator.detected {
            background: #fee2e2;
            border-color: #ef4444;
            color: #dc2626;
        }

        .race-condition-indicator.passed {
            background: #d1fae5;
            border-color: #10b981;
            color: #065f46;
        }

        .recording-pulse {
            display: inline-block;
            width: 12px;
            height: 12px;
            background: #ef4444;
            border-radius: 50%;
            animation: pulse 1.2s infinite;
            margin-right: 6px;
        }

        @keyframes pulse {
            0% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.4; transform: scale(1.3); }
            100% { opacity: 1; transform: scale(1); }
        }

        .chunk-timeline {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-top: 10px;
        }

        .chunk-item {
            width: 30px;
            height: 20px;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            font-weight: 600;
            color: white;
        }

        .chunk-item.sent {
            background: #3b82f6;
        }

        .chunk-item.processing {
            background: #f59e0b;
            animation: pulse 1s infinite;
        }

        .chunk-item.completed {
            background: #10b981;
        }

        .chunk-item.error {
            background: #ef4444;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ü©∫ Medical Transcription Test Client</h1>
            <p>Race condition detection & production stress testing</p>
        </div>

        <div class="content">
            <!-- Configuration -->
            <div class="section full-width">
                <h3>‚öôÔ∏è Configuration</h3>
                <div class="test-grid">
                    <div class="input-group">
                        <label>API Base URL:</label>
                        <input type="text" id="apiUrl" value="http://localhost:8000">
                    </div>
                    <div class="input-group">
                        <label>Doctor ID:</label>
                        <input type="text" id="doctorId" value="dr_test_001">
                    </div>
                    <div class="input-group">
                        <label>Patient Name:</label>
                        <input type="text" id="patientName" value="Test Patient">
                    </div>
                </div>
                <button class="btn" onclick="initializeSystem()">üöÄ Initialize System</button>
                <button class="btn warning" onclick="runStressTest()">‚ö° Stress Test</button>
                <button class="btn small" onclick="clearLogs()">Clear Logs</button>
            </div>

            <div class="test-grid">
                <!-- Session Status -->
                <div class="section">
                    <h3>
                        <span class="status-dot" id="sessionStatus"></span>
                        üìã Session
                    </h3>
                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-value" id="sessionIdDisplay">-</div>
                            <div class="stat-label">Session</div>
                        </div>
                    </div>
                    <button class="btn small" onclick="createSession()">Create</button>
                    <div class="response-box" id="sessionResponse"></div>
                </div>

                <!-- Transcription Status -->
                <div class="section">
                    <h3>
                        <span class="status-dot" id="transcriptionStatus"></span>
                        üé§ Transcription
                    </h3>
                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-value" id="transcriptionIdDisplay">-</div>
                            <div class="stat-label">T-Session</div>
                        </div>
                    </div>
                    <button class="btn small" onclick="startTranscription()" disabled id="startTranscriptionBtn">Start</button>
                    <button class="btn small danger" onclick="endTranscription()" disabled id="endTranscriptionBtn">End</button>
                    <div class="response-box" id="transcriptionResponse"></div>
                </div>

                <!-- WebSocket Status -->
                <div class="section">
                    <h3>
                        <span class="status-dot" id="wsStatus"></span>
                        üîó WebSocket
                    </h3>
                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-value" id="wsMessages">0</div>
                            <div class="stat-label">Messages</div>
                        </div>
                    </div>
                    <button class="btn small" onclick="connectWebSocket()" disabled id="connectBtn">Connect</button>
                    <button class="btn small danger" onclick="disconnectWebSocket()" disabled id="disconnectBtn">Disconnect</button>
                    <div class="response-box" id="wsResponse"></div>
                </div>
            </div>

            <!-- Test Mode Selection -->
            <div class="section full-width">
                <h3>üß™ Test Modes</h3>
                <div class="test-mode-selector">
                    <div class="test-mode active" onclick="selectTestMode('normal')" id="modeNormal">
                        üì± Normal Mode<br><small>8s chunks, realistic</small>
                    </div>
                    <div class="test-mode" onclick="selectTestMode('race')" id="modeRace">
                        ‚ö° Race Test<br><small>Rapid concurrent</small>
                    </div>
                    <div class="test-mode" onclick="selectTestMode('stress')" id="modeStress">
                        üí™ Stress Test<br><small>High load</small>
                    </div>
                    <div class="test-mode" onclick="selectTestMode('error')" id="modeError">
                        üí• Error Test<br><small>Failure scenarios</small>
                    </div>
                </div>
                
                <div class="race-condition-indicator" id="raceIndicator">
                    üîç Race condition detection: Ready to test
                </div>
            </div>

            <!-- Audio Recording -->
            <div class="section half-width">
                <h3>üéôÔ∏è Audio Recording</h3>
                
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value" id="chunkCount">0</div>
                        <div class="stat-label">Chunks</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="avgProcessTime">0</div>
                        <div class="stat-label">Avg (ms)</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="totalWords">0</div>
                        <div class="stat-label">Words</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="errorCount">0</div>
                        <div class="stat-label">Errors</div>
                    </div>
                </div>

                <button class="btn success" onclick="startRecording()" disabled id="recordBtn">
                    üé§ Start Recording
                </button>
                <button class="btn danger" onclick="stopRecording()" disabled id="stopBtn">
                    ‚èπÔ∏è Stop
                </button>
                <button class="btn small warning" onclick="sendTestChunk()">üì¶ Send Test Chunk</button>

                <p id="recordingStatus">Ready to record</p>
                
                <div class="chunk-timeline" id="chunkTimeline"></div>
            </div>

            <!-- Live Transcript -->
            <div class="section">
                <h3>üìù Live Transcript</h3>
                <div class="transcript-container empty" id="transcript">
                    Start recording to see transcript appear here...
                </div>
            </div>

            <!-- System Logs -->
            <div class="section full-width">
                <h3>üìä System Logs</h3>
                <div class="log-container" id="logs"></div>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let currentSessionId = null;
        let transcriptionSessionId = null;
        let websocket = null;
        let mediaRecorder = null;
        let audioStream = null;
        let sequenceNumber = 0;
        let processingTimes = [];
        let wsMessageCount = 0;
        let chunkStates = new Map(); // Track chunk processing states
        let testMode = 'normal';
        let raceConditionDetected = false;
        let expectedSequence = 0;
        let receivedSequences = [];

        // Logging
        function addLog(message, type = 'info') {
            const logs = document.getElementById('logs');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.innerHTML = `<strong>${new Date().toLocaleTimeString()}</strong> ${message}`;
            logs.appendChild(entry);
            logs.scrollTop = logs.scrollHeight;
        }

        function clearLogs() {
            document.getElementById('logs').innerHTML = '';
            addLog('Logs cleared', 'info');
        }

        function updateStatus(elementId, connected) {
            const indicator = document.getElementById(elementId);
            if (connected) {
                indicator.classList.add('connected');
            } else {
                indicator.classList.remove('connected');
            }
        }

        function selectTestMode(mode) {
            testMode = mode;
            document.querySelectorAll('.test-mode').forEach(el => el.classList.remove('active'));
            document.getElementById(`mode${mode.charAt(0).toUpperCase() + mode.slice(1)}`).classList.add('active');
            
            addLog(`Test mode changed to: ${mode}`, 'info');
            
            // Update race condition indicator
            const indicator = document.getElementById('raceIndicator');
            if (mode === 'race') {
                indicator.textContent = '‚ö° Race condition test mode: Will send rapid chunks to test ordering';
                indicator.className = 'race-condition-indicator';
            } else if (mode === 'stress') {
                indicator.textContent = 'üí™ Stress test mode: High volume concurrent processing';
                indicator.className = 'race-condition-indicator';
            } else {
                indicator.textContent = 'üîç Race condition detection: Monitoring sequence order';
                indicator.className = 'race-condition-indicator';
            }
        }

        function addChunkToTimeline(sequence, state) {
            const timeline = document.getElementById('chunkTimeline');
            let chunk = document.getElementById(`chunk-${sequence}`);
            
            if (!chunk) {
                chunk = document.createElement('div');
                chunk.className = `chunk-item ${state}`;
                chunk.id = `chunk-${sequence}`;
                chunk.textContent = sequence;
                timeline.appendChild(chunk);
            } else {
                chunk.className = `chunk-item ${state}`;
            }
        }

        // Session Management
        async function createSession() {
            const apiUrl = document.getElementById('apiUrl').value;
            const doctorId = document.getElementById('doctorId').value;
            const patientName = document.getElementById('patientName').value;

            try {
                addLog('Creating session...', 'info');
                
                const response = await fetch(`${apiUrl}/v1/sessions/create`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        doctor_id: doctorId,
                        patient_name: patientName,
                        patient_whatsapp_number: `+1555${Date.now().toString().slice(-4)}`
                    })
                });

                const data = await response.json();
                document.getElementById('sessionResponse').innerHTML = JSON.stringify(data, null, 2);

                if (response.ok && data.success) {
                    currentSessionId = data.session.session_id;
                    addLog(`Session created: ${currentSessionId}`, 'success');
                    updateStatus('sessionStatus', true);
                    document.getElementById('sessionIdDisplay').textContent = currentSessionId.slice(-6);
                    document.getElementById('sessionResponse').className = 'response-box success';
                    document.getElementById('startTranscriptionBtn').disabled = false;
                } else {
                    throw new Error(data.detail || 'Failed to create session');
                }
            } catch (error) {
                addLog(`Session creation failed: ${error.message}`, 'error');
                document.getElementById('sessionResponse').className = 'response-box error';
            }
        }

        // Transcription Management
        async function startTranscription() {
            const apiUrl = document.getElementById('apiUrl').value;
            try {
                addLog('Starting transcription...', 'info');
                
                const response = await fetch(`${apiUrl}/v1/transcription/start`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ session_id: currentSessionId })
                });

                const data = await response.json();
                document.getElementById('transcriptionResponse').innerHTML = JSON.stringify(data, null, 2);

                if (response.ok && data.success) {
                    transcriptionSessionId = data.transcription_session_id;
                    addLog(`Transcription started: ${transcriptionSessionId}`, 'success');
                    updateStatus('transcriptionStatus', true);
                    document.getElementById('transcriptionIdDisplay').textContent = transcriptionSessionId.slice(-6);
                    document.getElementById('transcriptionResponse').className = 'response-box success';
                    document.getElementById('connectBtn').disabled = false;
                    document.getElementById('endTranscriptionBtn').disabled = false;
                } else {
                    throw new Error(data.detail || 'Failed to start transcription');
                }
            } catch (error) {
                addLog(`Transcription start failed: ${error.message}`, 'error');
                document.getElementById('transcriptionResponse').className = 'response-box error';
            }
        }

        async function endTranscription() {
            const apiUrl = document.getElementById('apiUrl').value;
            try {
                addLog('Ending transcription...', 'info');
                
                const response = await fetch(`${apiUrl}/v1/transcription/end`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ transcription_session_id: transcriptionSessionId })
                });

                const data = await response.json();
                if (response.ok && data.success) {
                    addLog('Transcription ended successfully', 'success');
                    updateStatus('transcriptionStatus', false);
                    transcriptionSessionId = null;
                    document.getElementById('transcriptionIdDisplay').textContent = '-';
                }
            } catch (error) {
                addLog(`Error ending transcription: ${error.message}`, 'error');
            }
        }

        // WebSocket Management
        function connectWebSocket() {
            const apiUrl = document.getElementById('apiUrl').value;
            const wsUrl = apiUrl.replace('http://', 'ws://').replace('https://', 'wss://');
            
            try {
                addLog('Connecting WebSocket...', 'websocket');
                websocket = new WebSocket(`${wsUrl}/v1/transcription/${transcriptionSessionId}/stream`);

                websocket.onopen = function(event) {
                    addLog('WebSocket connected', 'websocket');
                    updateStatus('wsStatus', true);
                    document.getElementById('recordBtn').disabled = false;
                    document.getElementById('disconnectBtn').disabled = false;
                    document.getElementById('connectBtn').disabled = true;
                    document.getElementById('wsResponse').textContent = 'Connected';
                    document.getElementById('wsResponse').className = 'response-box success';
                };

                websocket.onmessage = function(event) {
                    try {
                        const data = JSON.parse(event.data);
                        wsMessageCount++;
                        document.getElementById('wsMessages').textContent = wsMessageCount;
                        
                        if (data.type === 'connection_confirmed') {
                            addLog('Connection confirmed', 'success');
                        } else if (data.type === 'transcript_update') {
                            handleTranscriptUpdate(data);
                        } else if (data.type === 'error') {
                            addLog(`WebSocket error: ${data.error_message}`, 'error');
                            document.getElementById('errorCount').textContent = parseInt(document.getElementById('errorCount').textContent) + 1;
                        } else if (data.type === 'metadata_received') {
                            addLog(`Metadata ack: chunk ${data.sequence_number}`, 'info');
                        }
                    } catch (error) {
                        addLog(`Error parsing WebSocket message: ${error.message}`, 'error');
                    }
                };

                websocket.onclose = function(event) {
                    addLog(`WebSocket closed (${event.code})`, 'websocket');
                    updateStatus('wsStatus', false);
                    resetWebSocketUI();
                };

                websocket.onerror = function(error) {
                    addLog('WebSocket error', 'error');
                };

            } catch (error) {
                addLog(`WebSocket connection failed: ${error.message}`, 'error');
            }
        }

        function disconnectWebSocket() {
            if (websocket) {
                websocket.close();
                websocket = null;
            }
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                stopRecording();
            }
            resetWebSocketUI();
        }

        function resetWebSocketUI() {
            document.getElementById('recordBtn').disabled = true;
            document.getElementById('stopBtn').disabled = true;
            document.getElementById('disconnectBtn').disabled = true;
            document.getElementById('connectBtn').disabled = false;
            document.getElementById('recordingStatus').textContent = 'Ready to record';
        }

        function handleTranscriptUpdate(data) {
            // Check for race condition (out-of-order responses)
            if (data.sequence_number !== expectedSequence) {
                raceConditionDetected = true;
                addLog(`üö® RACE CONDITION DETECTED! Expected sequence ${expectedSequence}, got ${data.sequence_number}`, 'error');
                
                const indicator = document.getElementById('raceIndicator');
                indicator.textContent = `üö® RACE CONDITION DETECTED! Out-of-order: expected ${expectedSequence}, got ${data.sequence_number}`;
                indicator.className = 'race-condition-indicator detected';
            } else {
                expectedSequence++;
                addLog(`‚úÖ Sequence ${data.sequence_number} arrived correctly`, 'success');
            }

            // Update transcript
            const transcriptBox = document.getElementById('transcript');
            transcriptBox.textContent = data.full_transcript;
            transcriptBox.classList.remove('empty');
            
            // Update chunk timeline
            addChunkToTimeline(data.sequence_number, 'completed');
            
            // Update stats
            processingTimes.push(data.processing_time_ms);
            const avgTime = Math.round(processingTimes.reduce((a, b) => a + b, 0) / processingTimes.length);
            document.getElementById('avgProcessTime').textContent = avgTime;
            
            const wordCount = data.full_transcript.split(' ').filter(w => w.length > 0).length;
            document.getElementById('totalWords').textContent = wordCount;
            
            addLog(`Transcript chunk ${data.sequence_number} (${data.processing_time_ms}ms): "${data.partial_transcript}"`, 'success');
        }

        // Audio Recording
        async function startRecording() {
            try {
                addLog(`Starting recording in ${testMode} mode...`, 'info');
                
                audioStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        sampleRate: 16000,
                        channelCount: 1,
                        echoCancellation: true,
                        noiseSuppression: true
                    } 
                });

                mediaRecorder = new MediaRecorder(audioStream, {
                    mimeType: 'audio/webm;codecs=opus'
                });

                let audioChunks = [];

                mediaRecorder.ondataavailable = function(event) {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                    }
                };

                mediaRecorder.onstop = function() {
                    if (audioChunks.length > 0) {
                        const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                        sendAudioChunk(audioBlob);
                        audioChunks = [];
                    }
                };

                // Different recording patterns based on test mode
                let chunkInterval;
                if (testMode === 'race') {
                    // Race condition test: 2-second chunks sent rapidly
                    mediaRecorder.start();
                    chunkInterval = setInterval(() => {
                        if (mediaRecorder && mediaRecorder.state === 'recording') {
                            mediaRecorder.stop();
                            setTimeout(() => {
                                if (mediaRecorder) {
                                    audioChunks = [];
                                    mediaRecorder.start();
                                }
                            }, 50); // Very short gap to create concurrency
                        }
                    }, 2000);
                } else if (testMode === 'stress') {
                    // Stress test: 1-second chunks
                    mediaRecorder.start();
                    chunkInterval = setInterval(() => {
                        if (mediaRecorder && mediaRecorder.state === 'recording') {
                            mediaRecorder.stop();
                            setTimeout(() => {
                                if (mediaRecorder) {
                                    audioChunks = [];
                                    mediaRecorder.start();
                                }
                            }, 10); // Minimal gap
                        }
                    }, 1000);
                } else {
                    // Normal mode: 8-second chunks
                    mediaRecorder.start();
                    chunkInterval = setInterval(() => {
                        if (mediaRecorder && mediaRecorder.state === 'recording') {
                            mediaRecorder.stop();
                            setTimeout(() => {
                                if (mediaRecorder) {
                                    audioChunks = [];
                                    mediaRecorder.start();
                                }
                            }, 100);
                        }
                    }, 8000);
                }

                mediaRecorder.chunkInterval = chunkInterval;

                addLog('Recording started', 'success');
                document.getElementById('recordingStatus').innerHTML = '<span class="recording-pulse"></span>Recording...';
                document.getElementById('recordBtn').disabled = true;
                document.getElementById('stopBtn').disabled = false;

            } catch (error) {
                addLog(`Recording failed: ${error.message}`, 'error');
            }
        }

        function stopRecording() {
            if (mediaRecorder) {
                if (mediaRecorder.chunkInterval) {
                    clearInterval(mediaRecorder.chunkInterval);
                }
                
                if (mediaRecorder.state === 'recording') {
                    mediaRecorder.stop();
                }
                
                mediaRecorder = null;
            }

            if (audioStream) {
                audioStream.getTracks().forEach(track => track.stop());
                audioStream = null;
            }

            addLog('Recording stopped', 'info');
            document.getElementById('recordingStatus').textContent = 'Ready to record';
            document.getElementById('recordBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
        }

        // Send audio chunk with NO ARTIFICIAL DELAYS - critical for race condition testing
        async function sendAudioChunk(audioBlob) {
            if (!websocket || websocket.readyState !== WebSocket.OPEN) {
                addLog('WebSocket not connected', 'error');
                return;
            }

            try {
                const arrayBuffer = await audioBlob.arrayBuffer();
                const currentSeq = sequenceNumber;
                
                // Add to timeline immediately
                addChunkToTimeline(currentSeq, 'sent');
                
                // Send metadata
                const metadata = {
                    type: 'audio_chunk_metadata',
                    sequence_number: currentSeq,
                    chunk_size_bytes: arrayBuffer.byteLength,
                    duration_seconds: testMode === 'race' ? 2.0 : (testMode === 'stress' ? 1.0 : 8.0)
                };

                websocket.send(JSON.stringify(metadata));
                
                // Send binary data immediately - NO setTimeout delay!
                websocket.send(arrayBuffer);
                
                sequenceNumber++;
                document.getElementById('chunkCount').textContent = sequenceNumber;
                
                // Update timeline to processing
                setTimeout(() => addChunkToTimeline(currentSeq, 'processing'), 50);
                
                addLog(`Sent chunk #${currentSeq} (${arrayBuffer.byteLength} bytes) - ${testMode} mode`, 'info');

            } catch (error) {
                addLog(`Error sending chunk: ${error.message}`, 'error');
                addChunkToTimeline(sequenceNumber - 1, 'error');
            }
        }

        // Send test chunk without recording
        async function sendTestChunk() {
            if (!websocket || websocket.readyState !== WebSocket.OPEN) {
                addLog('WebSocket not connected', 'error');
                return;
            }

            // Generate fake audio data for testing
            const fakeAudioSize = 50000 + Math.random() * 100000; // Variable size
            const fakeAudioData = new ArrayBuffer(fakeAudioSize);
            
            const currentSeq = sequenceNumber;
            addChunkToTimeline(currentSeq, 'sent');
            
            const metadata = {
                type: 'audio_chunk_metadata',
                sequence_number: currentSeq,
                chunk_size_bytes: fakeAudioSize,
                duration_seconds: 8.0
            };

            websocket.send(JSON.stringify(metadata));
            websocket.send(fakeAudioData);
            
            sequenceNumber++;
            document.getElementById('chunkCount').textContent = sequenceNumber;
            setTimeout(() => addChunkToTimeline(currentSeq, 'processing'), 50);
            
            addLog(`Sent test chunk #${currentSeq} (${fakeAudioSize} bytes)`, 'info');
        }

        // Complete initialization
        async function initializeSystem() {
            addLog('Initializing system...', 'info');
            
            // Reset all state
            sequenceNumber = 0;
            expectedSequence = 0;
            processingTimes = [];
            wsMessageCount = 0;
            raceConditionDetected = false;
            
            // Reset UI
            document.getElementById('chunkCount').textContent = '0';
            document.getElementById('avgProcessTime').textContent = '0';
            document.getElementById('totalWords').textContent = '0';
            document.getElementById('errorCount').textContent = '0';
            document.getElementById('wsMessages').textContent = '0';
            document.getElementById('chunkTimeline').innerHTML = '';
            
            const transcriptBox = document.getElementById('transcript');
            transcriptBox.textContent = 'Start recording to see transcript appear here...';
            transcriptBox.classList.add('empty');
            
            // Auto-fill test data
            const now = new Date();
            document.getElementById('patientName').value = `Test Patient ${now.getHours()}:${now.getMinutes()}`;
            
            // Start the flow
            await createSession();
            if (currentSessionId) {
                await startTranscription();
                if (transcriptionSessionId) {
                    connectWebSocket();
                }
            }
        }

        // Stress test - sends multiple rapid chunks
        async function runStressTest() {
            if (!websocket || websocket.readyState !== WebSocket.OPEN) {
                addLog('Connect WebSocket first', 'error');
                return;
            }

            addLog('üöÄ Starting stress test - sending 5 rapid chunks...', 'warning');
            
            const raceIndicator = document.getElementById('raceIndicator');
            raceIndicator.textContent = 'üöÄ Stress test running - monitoring for race conditions...';
            raceIndicator.className = 'race-condition-indicator';
            
            // Send 5 chunks rapidly to test concurrency
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    sendTestChunk();
                }, i * 200); // 200ms apart - likely to cause race conditions
            }
            
            // Check results after expected processing time
            setTimeout(() => {
                if (!raceConditionDetected) {
                    addLog('‚úÖ Stress test PASSED - no race conditions detected!', 'success');
                    raceIndicator.textContent = '‚úÖ Stress test PASSED - proper sequence ordering maintained';
                    raceIndicator.className = 'race-condition-indicator passed';
                } else {
                    addLog('‚ùå Stress test FAILED - race condition detected', 'error');
                }
            }, 15000);
        }

        // Error simulation
        function simulateError() {
            if (websocket) {
                // Send malformed message
                websocket.send('{"type":"invalid","malformed":true');
                addLog('Sent malformed message to test error handling', 'warning');
            }
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            addLog('Medical Transcription Test Client loaded', 'info');
            addLog('Use Initialize System to start, or test individual components', 'info');
            addLog('Use Race Test mode to detect concurrency bugs', 'warning');
            
            // Set up error test mode button
            document.getElementById('modeError').addEventListener('click', function() {
                setTimeout(() => {
                    const errorBtn = document.createElement('button');
                    errorBtn.className = 'btn small warning';
                    errorBtn.textContent = 'üí• Simulate Error';
                    errorBtn.onclick = simulateError;
                    this.appendChild(errorBtn);
                }, 100);
            });
        });
    </script>
</body>
</html>